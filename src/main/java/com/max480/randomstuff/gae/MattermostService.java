package com.max480.randomstuff.gae;

import com.google.appengine.api.datastore.*;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;
import org.apache.commons.text.StringEscapeUtils;
import org.json.JSONArray;
import org.json.JSONObject;
import org.jsoup.Connection;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.nodes.TextNode;
import org.jsoup.select.Elements;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.time.format.FormatStyle;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import static java.nio.charset.StandardCharsets.UTF_8;

/**
 * APIs that provide utility and meme stuff, for use as Mattermost slash commands.
 * Some of them are public (in French though), and others require a key to use.
 * Most of those just pull info from some website and reformat it.
 */
@WebServlet(name = "MattermostService", loadOnStartup = 4, urlPatterns = {"/mattermost/tableflip", "/mattermost/bientotleweekend",
        "/mattermost/vacances", "/mattermost/chucknorris", "/mattermost/random", "/mattermost/toplyrics",
        "/mattermost/ckc", "/mattermost/jcvd", "/mattermost/languedebois", "/mattermost/noel", "/mattermost/joiesducode",
        "/mattermost/patoche", "/mattermost/coronavirus", "/mattermost/fakename", "/mattermost/tendancesyoutube", "/mattermost/putaclic",
        "/mattermost/exploit", "/mattermost/absents", "/mattermost/randomparrot", "/mattermost/monkeyuser", "/mattermost/xkcd",
        "/mattermost/lock", "/mattermost/unlock", "/mattermost/planning-reload", "/mattermost/consistencycheck", "/mattermost/infopipo",
        "/mattermost/weekend", "/mattermost/eddy", "/mattermost/pipo"})
public class MattermostService extends HttpServlet {

    private final Logger logger = Logger.getLogger("MattermostService");
    private final DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();

    // those are the resources that can be locked or unlocked through /lock and /unlock
    private final List<String> resources = Arrays.asList("integ1", "integ2");

    private PlanningExploit cachedPlanningExploit;

    @Override
    public void init() {
        try {
            cachedPlanningExploit = getExploit();
        } catch (Exception e) {
            logger.log(Level.WARNING, "Preloading planning failed: " + e.toString());
        }
    }

    private static class PlanningExploit {
        private final List<ZonedDateTime> exploitTimes = new ArrayList<>();
        private final List<String> principalExploit = new ArrayList<>();
        private final List<String> backupExploit = new ArrayList<>();

        private final Map<String, List<Pair<ZonedDateTime, ZonedDateTime>>> holidays = new HashMap<>();
    }

    private PlanningExploit getExploit() throws IOException {
        PlanningExploit exploit = new PlanningExploit();

        // the "exploit" planning is stored in iCalendar format and has someone as "principal" and one as "backup" every week.
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new URL(SecretConstants.EXPLOIT_PLANNING_URL).openStream()))) {
            // date => name
            TreeMap<String, String> principals = new TreeMap<>();
            TreeMap<String, String> backups = new TreeMap<>();

            // jank iCal parser incoming!
            String line;
            while ((line = reader.readLine()) != null) {
                if (line.equals("BEGIN:VEVENT")) {
                    Map<String, String> properties = new HashMap<>();
                    String propertyBeingParsed = null;
                    String propertyValue = null;

                    // get event fields until we hit the end of it
                    while (!(line = reader.readLine()).equals("END:VEVENT")) {
                        if (propertyBeingParsed == null || !line.startsWith(" ")) {
                            // start of another property
                            if (propertyBeingParsed != null) {
                                properties.put(propertyBeingParsed, propertyValue);
                            }

                            // [name]:[value] or [name];[value]
                            if (line.contains(":")) {
                                propertyBeingParsed = line.substring(0, line.indexOf(":"));
                                propertyValue = line.substring(line.indexOf(":") + 1);
                            } else {
                                propertyBeingParsed = line.substring(0, line.indexOf(";"));
                                propertyValue = line.substring(line.indexOf(";") + 1);
                            }
                        } else {
                            // lines starting with a space are a continuation of the previous one.
                            propertyValue += line.substring(1);
                        }
                    }

                    // add the last property of the event
                    if (propertyBeingParsed != null) {
                        properties.put(propertyBeingParsed, propertyValue);
                    }

                    // is this a valid exploit entry?
                    if ("Exploitation".equals(properties.get("CATEGORIES")) && Arrays.asList("Principal", "Backup").contains(properties.get("SUMMARY"))
                            && properties.containsKey("DTSTART;VALUE=DATE") && properties.getOrDefault("ATTENDEE", "").contains("CN=")) {

                        // extract user
                        String userName = properties.get("ATTENDEE");
                        userName = userName.substring(userName.indexOf("CN=") + 3);
                        userName = userName.substring(0, userName.indexOf(";"));

                        // put it in the appropriate map
                        if (properties.get("SUMMARY").equals("Principal")) {
                            principals.put(properties.get("DTSTART;VALUE=DATE"), userName);
                        } else {
                            backups.put(properties.get("DTSTART;VALUE=DATE"), userName);
                        }
                    }

                    // is this a valid holidays entry?
                    if (Arrays.asList("Formation Ã‰cole", "leaves", "Formation").contains(properties.get("CATEGORIES"))
                            && (properties.containsKey("DTSTART;VALUE=DATE") || properties.containsKey("DTSTART;TZID=Europe/Paris"))
                            && (properties.containsKey("DTEND;VALUE=DATE") || properties.containsKey("DTEND;TZID=Europe/Paris"))
                            && properties.getOrDefault("ATTENDEE", "").contains("CN=")) {

                        // get the user
                        String userName = properties.get("ATTENDEE");
                        userName = userName.substring(userName.indexOf("CN=") + 3);
                        userName = userName.substring(0, userName.indexOf(";"));

                        // parse the date (that can contain a time or not) and put it in the planning
                        List<Pair<ZonedDateTime, ZonedDateTime>> userHolidays = exploit.holidays.getOrDefault(userName, new ArrayList<>());
                        userHolidays.add(new ImmutablePair<>(
                                properties.containsKey("DTSTART;VALUE=DATE") ?
                                        LocalDate.parse(properties.get("DTSTART;VALUE=DATE"), DateTimeFormatter.ofPattern("yyyyMMdd"))
                                                .atTime(0, 0, 0).atZone(ZoneId.of("Europe/Paris")) :
                                        LocalDateTime.parse(properties.get("DTSTART;TZID=Europe/Paris"), DateTimeFormatter.ofPattern("yyyyMMdd'T'HHmmss"))
                                                .atZone(ZoneId.of("Europe/Paris")),
                                properties.containsKey("DTEND;VALUE=DATE") ?
                                        LocalDate.parse(properties.get("DTEND;VALUE=DATE"), DateTimeFormatter.ofPattern("yyyyMMdd"))
                                                .atTime(0, 0, 0).atZone(ZoneId.of("Europe/Paris")) :
                                        LocalDateTime.parse(properties.get("DTEND;TZID=Europe/Paris"), DateTimeFormatter.ofPattern("yyyyMMdd'T'HHmmss"))
                                                .atZone(ZoneId.of("Europe/Paris"))));
                        exploit.holidays.put(userName, userHolidays);
                    }
                }
            }

            for (String date : principals.keySet()) {
                if (backups.containsKey(date)) {
                    // if we have a principal/backup pair, add it to the planning, starting on Monday 8am
                    exploit.principalExploit.add(principals.get(date));
                    exploit.backupExploit.add(backups.get(date));
                    exploit.exploitTimes.add(LocalDate.parse(date, DateTimeFormatter.ofPattern("yyyyMMdd"))
                            .atTime(8, 0).atZone(ZoneId.of("Europe/Paris")));
                }
            }

            // remove past exploit entries
            exploit.exploitTimes.remove(0);
            while (!exploit.exploitTimes.isEmpty() && exploit.exploitTimes.get(0).isBefore(ZonedDateTime.now())) {
                exploit.exploitTimes.remove(0);
                exploit.principalExploit.remove(0);
                exploit.backupExploit.remove(0);
            }

            // cleanup past holidays
            for (List<Pair<ZonedDateTime, ZonedDateTime>> holidays : exploit.holidays.values()) {
                holidays.removeIf(holiday -> holiday.getRight().isBefore(ZonedDateTime.now()));
            }

            logger.info("Exploit entries count: " + exploit.principalExploit.size());
            logger.info("Holiday entries count: " + exploit.holidays.values().stream().mapToInt(List::size).sum());

            return exploit;
        }
    }

    @Override
    public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
        if (request.getRequestURI().equals("/mattermost/planning-reload")
                && ("key=" + SecretConstants.CATALOG_RELOAD_SHARED_SECRET).equals(request.getQueryString())) {

            cachedPlanningExploit = getExploit();
        } else {
            response.setStatus(404);
        }
    }

    @Override
    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {
        switch (request.getRequestURI()) {
            case "/mattermost/tableflip":
                response.setHeader("Content-Type", "application/json");
                response.getWriter().write("{\"response_type\": \"in_channel\", \"text\": \"(\\u256f\\u00b0\\u25a1\\u00b0\\uff09\\u256f\\ufe35 \\u253b\\u2501\\u253b\"}");
                break;
            case "/mattermost/random": {
                response.setHeader("Content-Type", "application/json");

                String number = request.getParameter("text");
                String responseString = commandRandom(number);
                response.getWriter().write(responseString);
                break;
            }
            case "/mattermost/vacances": {
                if (!Arrays.asList(SecretConstants.MATTERMOST_TOKEN_VACANCES.split(";")).contains(request.getParameter("token"))) {
                    logger.log(Level.WARNING, "A wrong token was given");
                    response.setStatus(403);
                    return;
                }

                response.setHeader("Content-Type", "application/json");

                String target = request.getParameter("text");
                String userId = request.getParameter("user_id");

                String responseString = commandVacances(target, userId);
                response.getWriter().write(responseString);
                break;
            }
            case "/mattermost/lock": {
                if (!SecretConstants.MATTERMOST_TOKEN_LOCK.equals(request.getParameter("token"))) {
                    logger.log(Level.WARNING, "A wrong token was given");
                    response.setStatus(403);
                    return;
                }

                response.setHeader("Content-Type", "application/json");

                String target = request.getParameter("text");
                String userId = request.getParameter("user_name");

                String responseString = commandLock(userId, target);
                response.getWriter().write(responseString);
                break;
            }
            case "/mattermost/unlock": {
                if (!SecretConstants.MATTERMOST_TOKEN_UNLOCK.equals(request.getParameter("token"))) {
                    logger.log(Level.WARNING, "A wrong token was given");
                    response.setStatus(403);
                    return;
                }

                response.setHeader("Content-Type", "application/json");

                String target = request.getParameter("text");
                String userId = request.getParameter("user_name");

                String responseString = commandUnlock(userId, target);
                response.getWriter().write(responseString);
                break;
            }
            case "/mattermost/exploit": {
                if (!SecretConstants.MATTERMOST_TOKEN_EXPLOIT.equals(request.getParameter("token"))) {
                    logger.log(Level.WARNING, "A wrong token was given");
                    response.setStatus(403);
                    return;
                }

                response.setHeader("Content-Type", "application/json");
                response.getWriter().write(commandExploit());
                break;
            }
            case "/mattermost/consistencycheck": {
                if (!("token=" + SecretConstants.MATTERMOST_TOKEN_CONSISTENCYCHECK).equals(request.getQueryString())) {
                    logger.log(Level.WARNING, "A wrong token was given");
                    response.setStatus(403);
                    return;
                }

                response.setHeader("Content-Type", "application/json");

                String responseString = commandConsistencyCheck(IOUtils.toString(request.getInputStream(), UTF_8));
                response.getWriter().write(responseString);
                break;
            }
            case "/mattermost/absents": {
                if (!SecretConstants.MATTERMOST_TOKEN_ABSENTS.equals(request.getParameter("token"))) {
                    logger.log(Level.WARNING, "A wrong token was given");
                    response.setStatus(403);
                    return;
                }

                response.setHeader("Content-Type", "application/json");
                response.getWriter().write(commandAbsents());
                break;
            }
            case "/mattermost/chucknorris": {
                response.setHeader("Content-Type", "application/json");

                String param = request.getParameter("text");

                String responseString = commandChuckNorris(param == null || !param.equals("all"));
                response.getWriter().write(responseString);
                break;
            }
            case "/mattermost/toplyrics":
                response.setHeader("Content-Type", "application/json");
                response.getWriter().write(commandTopLyrics(false));
                break;
            case "/mattermost/patoche":
                response.setHeader("Content-Type", "application/json");
                response.getWriter().write(commandTopLyrics(true));
                break;
            case "/mattermost/ckc":
                response.setHeader("Content-Type", "application/json");
                response.getWriter().write("{\"response_type\": \"in_channel\", \"text\": \"https://max480-random-stuff.appspot.com/estcequeckc.html\"}");
                break;
            case "/mattermost/jcvd": {
                response.setHeader("Content-Type", "application/json");

                String responseString = commandJCVD();
                response.getWriter().write(responseString);
                break;
            }
            case "/mattermost/languedebois": {
                response.setHeader("Content-Type", "application/json");

                String responseString = commandLangueDeBois();
                response.getWriter().write(responseString);
                break;
            }
            case "/mattermost/bientotleweekend": {
                response.setHeader("Content-Type", "application/json");

                String responseString = commandBientotLeWeekend();
                response.getWriter().write(responseString);
                break;
            }
            case "/mattermost/noel": {
                response.setHeader("Content-Type", "application/json");

                String responseString = ChristmasFilmGenerator.generateStory();
                response.getWriter().write(responseString);
                break;
            }
            case "/mattermost/joiesducode": {
                response.setHeader("Content-Type", "application/json");

                String responseString = commandJoiesDuCode();
                response.getWriter().write(responseString);
                break;
            }
            case "/mattermost/coronavirus": {
                response.setHeader("Content-Type", "application/json");

                String responseString = commandCoronavirus();
                response.getWriter().write(responseString);
                break;
            }
            case "/mattermost/fakename": {
                response.setHeader("Content-Type", "application/json");

                String responseString = commandFakeName();
                response.getWriter().write(responseString);
                break;
            }
            case "/mattermost/putaclic": {
                response.setHeader("Content-Type", "application/json");

                String responseString = commandPutaclic();
                response.getWriter().write(responseString);
                break;
            }
            case "/mattermost/tendancesyoutube": {
                response.setHeader("Content-Type", "application/json");

                String responseString = commandTendancesYoutube();
                response.getWriter().write(responseString);
                break;
            }
            case "/mattermost/randomparrot": {
                response.setHeader("Content-Type", "application/json");

                String responseString = commandRandomParrot();
                response.getWriter().write(responseString);
                break;
            }
            case "/mattermost/monkeyuser": {
                response.setHeader("Content-Type", "application/json");

                String responseString = commandMonkeyUser();
                response.getWriter().write(responseString);
                break;
            }
            case "/mattermost/xkcd": {
                response.setHeader("Content-Type", "application/json");

                String responseString = commandXkcd();
                response.getWriter().write(responseString);
                break;
            }
            case "/mattermost/infopipo": {
                response.setHeader("Content-Type", "application/json");

                String responseString = commandInfoPipo();
                response.getWriter().write(responseString);
                break;
            }
            case "/mattermost/weekend": {
                response.setHeader("Content-Type", "application/json");

                String responseString = commandWeekend(request.getParameter("user_name"));
                response.getWriter().write(responseString);
                break;
            }
            case "/mattermost/eddy": {
                response.setHeader("Content-Type", "application/json");

                String responseString = commandEddy();
                response.getWriter().write(responseString);
                break;
            }
            case "/mattermost/pipo": {
                response.setHeader("Content-Type", "application/json");

                String responseString = commandPipo(request.getParameter("text"), request.getParameter("user_name"));
                response.getWriter().write(responseString);
                break;
            }
            default: {
                response.setStatus(404);
                break;
            }
        }
    }

    private String commandBientotLeWeekend() {
        JSONObject jsonObject = new JSONObject();
        try {
            jsonObject.put("text", "_Est-ce que c'est bientÃ´t le week-end ?_\n" +
                    Jsoup.connect("https://estcequecestbientotleweekend.fr/").get().select(".msg")
                            .stream().map(Element::text).collect(Collectors.joining("\n")));
            jsonObject.put("response_type", "in_channel");
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Problem with /bientotleweekend: " + e.toString());
            jsonObject.put("text", "DÃ©solÃ©, la slash command n'a pas fonctionnÃ©. :ckc:");
        }

        return jsonObject.toString();
    }

    private String commandLangueDeBois() {
        JSONObject jsonObject = new JSONObject();
        try {
            jsonObject.put("text", Jsoup.connect("https://www.faux-texte.com/langue-bois-2.htm").get()
                    .select("#TheTexte p")
                    .stream().map(element -> {
                        String s = element.text();
                        if (!s.endsWith(".")) s += ".";
                        return s;
                    }).collect(Collectors.joining("\n")));
            jsonObject.put("response_type", "in_channel");
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Problem with /languedebois: " + e.toString());
            jsonObject.put("text", "DÃ©solÃ©, l'appel Ã  faux-texte.com a Ã©chouÃ©. :ckc:");
        }

        return jsonObject.toString();
    }

    private String commandJCVD() {
        JSONObject jsonObject = new JSONObject();
        try {
            jsonObject.put("text", Jsoup.connect("https://www.faux-texte.com/jean-claude-2.htm").get()
                    .select("#TheTexte p").get(0).text());
            jsonObject.put("response_type", "in_channel");
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Problem with /jcvd: " + e.toString());
            jsonObject.put("text", "DÃ©solÃ©, l'appel Ã  faux-texte.com a Ã©chouÃ©. :ckc:");
        }

        return jsonObject.toString();
    }

    private String commandChuckNorris(boolean onlyGood) {
        JSONObject jsonObject = new JSONObject();

        try {
            if (onlyGood) {
                while (!jsonObject.has("text")) {
                    // only more than 7/10 mark!
                    Document facts = Jsoup.connect("https://chucknorrisfacts.fr/facts/random").get();

                    List<String> text = facts.select(".card-text").stream().map(Element::text).collect(Collectors.toList());
                    List<Float> marks = facts.select(".card-footer span").stream()
                            .map(Element::text)
                            .map(mark -> {
                                // the format is (XXX/10)
                                mark = mark.substring(1, mark.length() - 4);
                                return Float.parseFloat(mark);
                            })
                            .collect(Collectors.toList());

                    for (int i = 0; i < marks.size(); i++) {
                        if (marks.get(i) >= 7) {
                            logger.info("Fact selected: \"" + text.get(i) + "\" with mark " + marks.get(i));

                            jsonObject.put("text", text.get(i));
                            break;
                        }
                    }
                }
            } else {
                // any random fact will do.
                jsonObject.put("text", Jsoup.connect("https://chucknorrisfacts.fr/facts/random").get()
                        .select(".card-text")
                        .get(0).text());
            }

            jsonObject.put("response_type", "in_channel");
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Problem with /chucknorris: " + e.toString());
            jsonObject.put("text", "DÃ©solÃ©, l'appel Ã  l'API de chucknorrisfacts.fr a Ã©chouÃ©. :ckc:");
        }

        return jsonObject.toString();
    }

    private String commandVacances(String target, String userId) {
        purgeVacances();

        JSONObject jsonObject = new JSONObject();
        if (target != null && !target.isEmpty()) {
            // define a new holiday date.
            try {
                ZonedDateTime targetDateTime = ZonedDateTime.of(LocalDate.parse(target, DateTimeFormatter.ofPattern("dd/MM/yyyy")),
                        LocalTime.of(18, 0, 0, 0), ZoneId.of("Europe/Paris"));

                logger.log(Level.INFO, "Countdown target is: " + targetDateTime.toString());

                if (targetDateTime.isBefore(ZonedDateTime.now())) {
                    // date is in the past
                    jsonObject.put("text", "La date que tu m'as donnÃ©e (" +
                            targetDateTime.format(DateTimeFormatter.ofPattern("d MMMM yyyy", Locale.FRENCH))
                            + ") est dans le passÃ©. Essaie encore. :confused:");
                } else {
                    // date is valid, save it
                    saveTheDate(userId, targetDateTime.toInstant().toEpochMilli());

                    jsonObject.put("text", "OK ! La date de tes vacances (" +
                            targetDateTime.format(DateTimeFormatter.ofPattern("d MMMM yyyy", Locale.FRENCH))
                            + ") a bien Ã©tÃ© enregistrÃ©e.\nTape `/vacances` pour avoir un compte Ã  rebours !");
                }
            } catch (DateTimeParseException ex) {
                // date is invalid
                logger.log(Level.WARNING, "Date parse error: " + ex.toString());
                jsonObject.put("text", "Je n'ai pas compris la date que tu m'as donnÃ©e en paramÃ¨tre.");
            }
        } else {
            // find out how much time is left until holidays
            Long targetSaved = findTheDate(userId);
            String message;
            if (targetSaved != null && (message = findDiff(targetSaved)) != null) {
                jsonObject.put("response_type", "in_channel");
                jsonObject.put("text", message);
            } else {
                // user has no holiday saved
                jsonObject.put("text", "Tu n'as pas dÃ©fini la date de tes vacances.\n" +
                        "Lance la commande `/vacances [JJ/MM/AAAA]` pour le faire.");
            }
        }

        return jsonObject.toString();
    }

    private void purgeVacances() {
        // purge past holidays from database
        final Query query = new Query("vacances").addFilter("target", Query.FilterOperator.LESS_THAN, System.currentTimeMillis() - 86_400_000L);
        for (Entity entity : datastore.prepare(query).asIterable()) {
            logger.info("Deleting holiday " + entity.getKey().toString() + " from the database because date is " +
                    new Date((long) entity.getProperty("target")));
            datastore.delete(entity.getKey());
        }
    }

    private String commandRandom(String numberParameter) {
        JSONObject jsonObject = new JSONObject();

        if (numberParameter == null || numberParameter.isEmpty()) {
            // no number passed
            jsonObject.put("text", "Utilisation : `/random [nombre]`");
        } else {
            try {
                int nb = Integer.parseInt(numberParameter);
                if (nb <= 0) {
                    // negative number passed
                    jsonObject.put("text", "Avec un nombre strictement positif Ã§a marchera mieux !");
                } else {
                    // all good!
                    jsonObject.put("response_type", "in_channel");
                    jsonObject.put("text", "[Tirage entre 1 et " + nb + "] J'ai tirÃ© : " + ((int) (Math.random() * nb + 1)));
                }
            } catch (NumberFormatException e) {
                // what was passed is not a number
                jsonObject.put("text", "Avec un nombre, Ã§a marchera mieux !");
            }
        }
        return jsonObject.toString();
    }

    private void saveTheDate(String userId, long target) {
        Entity datastoreEntity = new Entity("vacances", userId);
        datastoreEntity.setProperty("target", target);

        datastore.put(datastoreEntity);
    }

    private Long findTheDate(String userId) {
        try {
            Entity datastoreEntity = datastore.get(KeyFactory.createKey("vacances", userId));
            return (long) datastoreEntity.getProperty("target");
        } catch (EntityNotFoundException e) {
            return null;
        }
    }

    private String commandLock(String user, String resource) {
        if (!resources.contains(resource)) {
            // trying to lock non-existent resource
            JSONObject jsonObject = new JSONObject();
            jsonObject.put("text", "La ressource que tu as demandÃ©e n'existe pas ! Les ressources valides sont : " + String.join(", ", resources));
            return jsonObject.toString();
        }

        String lockedBy = figureOutWhoLocked(resource);

        JSONObject jsonObject = new JSONObject();
        jsonObject.put("response_type", "in_channel");

        if (lockedBy != null) {
            if (lockedBy.equals(user)) {
                // user has locked resource
                jsonObject.put("text", ":x: Tu as dÃ©jÃ  verrouillÃ© la ressource **" + resource + "**. :thinking:");
            } else {
                // user tries to lock a resource already locked by someone else
                jsonObject.put("text", ":x: La ressource **" + resource + "** est actuellement verrouillÃ©e par @" + lockedBy + " ! :a:");
            }
        } else {
            // all good, lock the resource
            Entity datastoreThing = new Entity("ressources", resource);
            datastoreThing.setProperty("lockedBy", user);
            datastoreThing.setProperty("lockTime", System.currentTimeMillis());
            datastore.put(datastoreThing);

            jsonObject.put("text", ":lock: @" + user + " a verrouillÃ© la ressource **" + resource + "**.");
        }

        return jsonObject.toString();
    }

    private String commandUnlock(String user, String resource) {
        if (!resources.contains(resource)) {
            // trying to unlock non-existent resource
            JSONObject jsonObject = new JSONObject();
            jsonObject.put("text", "La ressource que tu as demandÃ©e n'existe pas ! Les ressources valides sont : " + String.join(", ", resources));
            return jsonObject.toString();
        }

        String lockedBy = figureOutWhoLocked(resource);

        JSONObject jsonObject = new JSONObject();
        jsonObject.put("response_type", "in_channel");

        if (lockedBy != null) {
            if (lockedBy.equals(user)) {
                // all good, unlock the resource
                datastore.delete(KeyFactory.createKey("ressources", resource));
                jsonObject.put("text", ":unlock: @" + user + " a dÃ©verrouillÃ© la ressource **" + resource + "**.");
            } else {
                // resource is locked... by someone else
                jsonObject.put("text", ":x: La ressource **" + resource + "** est verrouillÃ©e par @" + lockedBy + ", tu ne peux pas la dÃ©verrouiller Ã  sa place ! :a:");
            }
        } else {
            // resource is not locked
            jsonObject.put("text", ":x: La ressource **" + resource + "** n'est pas verrouillÃ©e actuellement. :thinking:");
        }

        return jsonObject.toString();
    }

    private String figureOutWhoLocked(String resource) {
        String lockedBy = null;
        try {
            Entity datastoreEntity = datastore.get(KeyFactory.createKey("ressources", resource));

            // locks expire after 12 hours.
            if ((long) datastoreEntity.getProperty("lockTime") > System.currentTimeMillis() - (12 * 3600 * 1000)) {
                lockedBy = (String) datastoreEntity.getProperty("lockedBy");
            }
        } catch (EntityNotFoundException e) {
            // oops, in that case lockedBy will stay null.
        }
        return lockedBy;
    }

    private String findDiff(long time) {
        long now = System.currentTimeMillis();

        long seconds = ((time - now) / (1000));
        long minutes = seconds / 60;
        seconds %= 60;

        long hours = minutes / 60;
        minutes %= 60;

        long days = hours / 24;
        hours %= 24;

        String phrase;

        if (time - now < 0 && time - now > -86_400_000L) {
            phrase = "**C'est les vacances ! \\o/**";
        } else if (time - now < 0) {
            return null;
        } else {
            phrase = "Les vacances sont dans "
                    + (days == 0 ? "" : days + " jour(s), ") + hours + " heure(s), " + minutes + " minute(s) et " + seconds + " seconde(s) !";
        }

        return phrase;
    }

    private String commandTopLyrics(boolean patoche) {
        JSONObject jsonObject = new JSONObject();

        try {
            // fetch song list
            Pair<List<String>, List<String>> results;
            if (patoche) {
                results = fetchPatocheList();
            } else {
                results = fetchSongList();
            }
            List<String> songTitles = results.getLeft();
            List<String> songUrls = results.getRight();

            // pick one at random
            int random = (int) (Math.random() * songTitles.size());
            String titre = songTitles.get(random);
            String url = songUrls.get(random);

            Document lyricsPage = Jsoup.connect(url).get();

            Elements songText = lyricsPage.select(".song-text div");
            String lyricsList = songText.stream()
                    .map(div -> div.childNodes().stream()
                            .map(element -> {
                                if (element instanceof TextNode) {
                                    return ((TextNode) element).text().trim();
                                } else if (element instanceof Element && ((Element) element).tagName().equals("br")) {
                                    return "\n";
                                }
                                return "";
                            })
                            .collect(Collectors.joining()))
                    .collect(Collectors.joining());

            // split the song in blocks like they are on the site
            while (lyricsList.contains("\n\n\n")) lyricsList = lyricsList.replace("\n\n\n", "\n\n");
            String[] lyricsSplit = lyricsList.split("\n\n");

            List<String> parolesFinal = new ArrayList<>();
            for (String parole : lyricsSplit) {
                List<String> lyricsParts = new ArrayList<>();
                lyricsParts.add(parole);

                // piece out the song in 5-line parts maximum, by cutting blocks in half until we're good
                while (lyricsParts.stream().anyMatch(parolePart -> parolePart.split("\n").length > 5)) {
                    List<String> newLyricsParts = new ArrayList<>();
                    for (String lyricsPart : lyricsParts) {
                        if (lyricsPart.split("\n").length > 5) {
                            // split in half
                            String[] lines = lyricsPart.split("\n");
                            StringBuilder firstBlock = new StringBuilder();
                            StringBuilder secondBlock = new StringBuilder();

                            int count = 0;
                            for (String line : lines) {
                                if (count++ < lines.length / 2) firstBlock.append(line).append("\n");
                                else secondBlock.append(line).append("\n");
                            }

                            newLyricsParts.add(firstBlock.toString().trim());
                            newLyricsParts.add(secondBlock.toString().trim());
                        } else {
                            newLyricsParts.add(lyricsPart);
                        }
                    }
                    lyricsParts = newLyricsParts;
                }

                parolesFinal.addAll(lyricsParts);
            }

            // then we just take a block at random and send it out. :p
            String randomLyrics = parolesFinal.get((int) (Math.random() * parolesFinal.size()));
            randomLyrics = "> " + randomLyrics.replace("\n", "\n> ");
            randomLyrics += "\n\n~ " + titre;

            jsonObject.put("response_type", "in_channel");
            jsonObject.put("text", randomLyrics);
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Problem with /toplyrics or /patoche: " + e.toString());
            jsonObject.put("text", ":ckc:");
        }

        return jsonObject.toString();
    }

    private Pair<List<String>, List<String>> fetchSongList() throws IOException {
        try {
            List<String> songTitles = new ArrayList<>();
            List<String> songUrls = new ArrayList<>();

            String[] artists = new String[]{"Jul", "Aya Nakamura", "Heuss L'EnfoirÃ©", "Gambi"};
            String[] urlLists = new String[]{
                    "https://www.paroles.net/jul", "https://www.paroles.net/aya-nakamura",
                    "https://www.paroles.net/heuss-l-enfoire", "https://www.paroles.net/gambi"};

            for (int i = 0; i < artists.length; i++) {
                final String artiste = artists[i];

                Document page = Jsoup.connect(urlLists[i]).get();

                List<String> titles = new ArrayList<>();
                List<String> urls = new ArrayList<>();

                page.select(".song-listing-extra").get(1).select("a")
                        .forEach(element -> {
                            String songurl = element.attr("href");
                            if (songurl.startsWith("/")) {
                                songurl = "https://www.paroles.net" + songurl;
                            }
                            urls.add(songurl);
                            titles.add(artiste + ", _" + element.text() + "_");
                        });

                logger.log(Level.INFO, artists[i] + " has " + urls.size() + " songs");

                songTitles.addAll(titles);
                songUrls.addAll(urls);
            }

            logger.log(Level.INFO, "Total: " + songUrls.size() + " songs");
            return Pair.of(songTitles, songUrls);
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Getting songs broke: " + e.toString());
            throw e;
        }
    }

    private Pair<List<String>, List<String>> fetchPatocheList() throws IOException {
        try {
            List<String> patocheTitles = new ArrayList<>();
            List<String> patocheUrls = new ArrayList<>();

            // hardcoded, we probably won't reach page 3 at any point :p
            for (String url : new String[]{"https://www.paroles.net/patrick-sebastien", "https://www.paroles.net/patrick-sebastien-2"}) {
                Document page = Jsoup.connect(url).get();

                List<String> titres = new ArrayList<>();
                List<String> urls = new ArrayList<>();

                page.select("div[typeof=\"v:Song\"] > .center-on-mobile.box-content")
                        .select("a")
                        .forEach(element -> {
                            String songurl = element.attr("href");
                            if (songurl.startsWith("/")) {
                                songurl = "https://www.paroles.net" + songurl;
                            }
                            urls.add(songurl);
                            titres.add("Patrick SÃ©bastien, _" + element.text() + "_");
                        });

                logger.log(Level.INFO, urls.size() + " chansons added to /patoche");

                patocheTitles.addAll(titres);
                patocheUrls.addAll(urls);
            }

            logger.log(Level.INFO, "Total /patoche: " + patocheUrls.size() + " songs");
            return Pair.of(patocheTitles, patocheUrls);
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Getting songs broke: " + e.toString());
            throw e;
        }
    }

    private String commandJoiesDuCode() {
        JSONObject jsonObject = null;
        try {
            while (jsonObject == null) {
                // just try until we succeed :a:
                jsonObject = tryLoadingJoiesDuCode();
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Problem with /joiesducode: " + e.toString());
            jsonObject.put("text", "DÃ©solÃ©, la rÃ©cupÃ©ration a Ã©chouÃ©. :ckc:");
        }

        return jsonObject.toString();
    }

    private JSONObject tryLoadingJoiesDuCode() throws IOException {
        JSONObject jsonObject = new JSONObject();

        Connection.Response resp = Jsoup.connect("https://lesjoiesducode.fr/random").execute();
        String url = resp.url().toString();
        Document content = Jsoup.parse(resp.body());
        String title = content.select(".blog-post-title").text();

        Elements gif = content.select(".blog-post-content object");
        Elements image = content.select(".blog-post-content img");

        String imageUrl = null;
        if (!gif.isEmpty()) {
            imageUrl = gif.attr("data");
        } else if (!image.isEmpty()) {
            imageUrl = image.attr("src");
        }

        if (imageUrl == null || (!imageUrl.startsWith("http://") && !imageUrl.startsWith("https://"))) {
            // if the result is anything other than an URL, just return null and we'll retry.
            return null;
        } else {
            HashMap<String, String> attachment = new HashMap<>();
            attachment.put("fallback", title + " : " + url);
            attachment.put("title", title);
            attachment.put("image_url", imageUrl);

            jsonObject.put("attachments", Collections.singletonList(attachment));
        }

        jsonObject.put("response_type", "in_channel");
        return jsonObject;
    }

    private static class CoronavirusStats {
        String country;
        int confirmed;
        int deaths;
        int recovered;

        public CoronavirusStats(String country, int confirmed, int deaths, int recovered) {
            this.country = country;
            this.confirmed = confirmed;
            this.deaths = deaths;
            this.recovered = recovered;
        }
    }

    private String commandCoronavirus() {
        JSONObject jsonObject = new JSONObject();

        try {
            // we need to spoof the user agent because a lot of things (CloudFlare?) hate Java 8 for some reason
            HttpURLConnection connection = (HttpURLConnection) new URL("https://disease.sh/v2/countries?sort=cases").openConnection();
            connection.setRequestProperty("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:74.0) Gecko/20100101 Firefox/74.0");
            connection.connect();

            // get coronavirus stats and aggregate them
            JSONArray countries = new JSONArray(IOUtils.toString(connection.getInputStream(), UTF_8));
            ArrayList<CoronavirusStats> stats = new ArrayList<>(countries.length());
            for (Object country : countries) {
                JSONObject countryObj = (JSONObject) country;
                stats.add(new CoronavirusStats(countryObj.getString("country"),
                        countryObj.getInt("cases"),
                        countryObj.getInt("deaths"),
                        countryObj.getInt("recovered")));
            }

            DecimalFormat format = new DecimalFormat("#,###", DecimalFormatSymbols.getInstance(Locale.FRANCE));

            // aggregated stats
            StringBuilder message = new StringBuilder("**Statistiques du coronavirus**\n__Dans le monde :__ ");
            message.append(format.format(stats.stream().mapToInt(s -> s.confirmed).sum())).append(" cas, ");
            message.append(format.format(stats.stream().mapToInt(s -> s.deaths).sum())).append(" morts, ");
            message.append(format.format(stats.stream().mapToInt(s -> s.recovered).sum())).append(" guÃ©ris\n__En France (**");

            // stats for France
            CoronavirusStats frenchStats = stats.stream().filter(s -> s.country.equals("France")).findFirst()
                    .orElseThrow(() -> new Exception("aaaa la France n'existe pas"));
            int francePosition = stats.indexOf(frenchStats) + 1;
            message.append(francePosition).append(francePosition == 1 ? "er" : "e").append("**) :__ ");
            message.append(format.format(frenchStats.confirmed)).append(" cas, ");
            message.append(format.format(frenchStats.deaths)).append(" morts, ");
            message.append(format.format(frenchStats.recovered)).append(" guÃ©ris\n\n__Top 5 :__\n");

            // top 5 countries
            int position = 1;
            for (CoronavirusStats countryStats : stats) {
                message.append("**").append(countryStats.country).append("** : ");
                message.append(format.format(countryStats.confirmed)).append(" cas, ");
                message.append(format.format(countryStats.deaths)).append(" morts, ");
                message.append(format.format(countryStats.recovered)).append(" guÃ©ris\n");

                if (++position > 5) break;
            }

            jsonObject.put("text", message.toString().trim());
            jsonObject.put("response_type", "in_channel");
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Problem with /coronavirus: " + e.toString());
            jsonObject.put("text", "DÃ©solÃ©, la rÃ©cupÃ©ration de la base de donnÃ©es a Ã©chouÃ©. :ckc:");
        }

        return jsonObject.toString();
    }

    private String commandFakeName() {
        JSONObject jsonObject = new JSONObject();

        try {
            Document document = Jsoup.connect("https://www.fakenamegenerator.com/gen-random-fr-fr.php").get();
            String name = "**" + document.select(".address h3").text() + "**\n"
                    + document.select(".address .adr").html().replace("<br>", "").trim();

            jsonObject.put("response_type", "in_channel");
            jsonObject.put("text", name);
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Problem with /fakename: " + e.toString());
            jsonObject.put("text", "DÃ©solÃ©, la rÃ©cupÃ©ration a Ã©chouÃ©. :ckc:");
        }

        return jsonObject.toString();
    }

    private static class VideoTendance {
        public int views;
        public ZonedDateTime publishedDate;
        public String author;
        public String title;
        public int position;
        public String id;
    }

    private String commandTendancesYoutube() {
        JSONObject jsonObject = new JSONObject();

        try {
            List<VideoTendance> tendancesYoutube = refreshTendancesYoutube();
            VideoTendance video = tendancesYoutube.get((int) (Math.random() * tendancesYoutube.size()));

            String text = "**" + video.title + "**\n" +
                    "_Par " + video.author + ", publiÃ© le " + video.publishedDate.format(DateTimeFormatter.ofPattern("dd MMMM yyyy 'Ã ' HH'h'mm", Locale.FRENCH)) + ", "
                    + new DecimalFormat("#,##0", DecimalFormatSymbols.getInstance(Locale.FRENCH)).format(video.views) + " vues" +
                    " - #" + video.position + " des tendances_\n:arrow_right: "
                    + "https://youtu.be/" + video.id;

            jsonObject.put("response_type", "in_channel");
            jsonObject.put("text", text);
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Problem while getting YouTube trends: " + e.toString());
            jsonObject.put("text", "DÃ©solÃ©, la rÃ©cupÃ©ration a Ã©chouÃ©. :ckc:");
        }

        return jsonObject.toString();
    }

    private List<VideoTendance> refreshTendancesYoutube() throws IOException {
        logger.log(Level.INFO, "Refresh YouTube trends");

        List<VideoTendance> tendancesYoutube = new ArrayList<>();

        JSONObject youtubeResponse = new JSONObject(IOUtils.toString(new URL("https://www.googleapis.com/youtube/v3/videos?hl=fr&maxResults=50" +
                "&regionCode=FR&chart=mostPopular&part=snippet,statistics&key=" + SecretConstants.YOUTUBE_API_KEY).openStream(), UTF_8));

        for (Object video : youtubeResponse.getJSONArray("items")) {
            try {
                VideoTendance videoObj = new VideoTendance();
                JSONObject snippet = ((JSONObject) video).getJSONObject("snippet");
                JSONObject statistics = ((JSONObject) video).getJSONObject("statistics");
                JSONObject localized = snippet.getJSONObject("localized");

                videoObj.author = snippet.getString("channelTitle");
                videoObj.publishedDate = ZonedDateTime.parse(snippet.getString("publishedAt"));
                videoObj.title = localized.getString("title");
                videoObj.views = Integer.parseInt(statistics.getString("viewCount"));
                videoObj.position = tendancesYoutube.size() + 1;
                videoObj.id = ((JSONObject) video).getString("id");
                tendancesYoutube.add(videoObj);
            } catch (Exception e) {
                logger.warning("Could not parse video: " + e);
            }
        }

        if (tendancesYoutube.isEmpty()) {
            throw new IOException("There is no valid video! :a:");
        }

        logger.log(Level.INFO, tendancesYoutube.size() + " videos found");
        return tendancesYoutube;
    }

    private String commandPutaclic() {
        JSONObject jsonObject = new JSONObject();

        try {
            Document document = Jsoup.connect("http://www.le-toaster.fr/generateur-buzz/").get();
            String text = document.select("article h2").text().trim();

            jsonObject.put("response_type", "in_channel");
            jsonObject.put("text", text);
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Problem with /putaclic: " + e.toString());
            jsonObject.put("text", "DÃ©solÃ©, la rÃ©cupÃ©ration a Ã©chouÃ©. :ckc:");
        }

        return jsonObject.toString();
    }

    private String commandExploit() {
        PlanningExploit exploit;
        try {
            exploit = cachedPlanningExploit == null ? getExploit() : cachedPlanningExploit;
        } catch (IOException e) {
            logger.log(Level.SEVERE, "Problem while getting exploit planning: " + e.toString());

            JSONObject jsonObject = new JSONObject();
            jsonObject.put("text", "DÃ©solÃ©, la rÃ©cupÃ©ration du planning d'exploit a Ã©chouÃ©. :ckc:");
            return jsonObject.toString();
        }

        JSONObject jsonObject = new JSONObject();

        StringBuilder messageBuilder = new StringBuilder("**Planning d'exploit**\nActuellement : **");
        messageBuilder.append(formatName(exploit.principalExploit.get(0))).append("**, backup **")
                .append(formatName(exploit.backupExploit.get(0))).append("**");

        for (int i = 0; i < exploit.exploitTimes.size(); i++) {
            messageBuilder.append("\n").append(DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT).withLocale(Locale.FRANCE).format(exploit.exploitTimes.get(i)))
                    .append(" : **").append(formatName(exploit.principalExploit.get(i + 1))).append("**, backup **")
                    .append(formatName(exploit.backupExploit.get(i + 1))).append("**");
        }

        jsonObject.put("response_type", "in_channel");
        jsonObject.put("text", messageBuilder.toString());
        return jsonObject.toString();
    }

    private String commandAbsents() {
        PlanningExploit exploit;
        try {
            exploit = cachedPlanningExploit == null ? getExploit() : cachedPlanningExploit;
        } catch (IOException e) {
            logger.log(Level.SEVERE, "Problem while getting exploit planning: " + e.toString());

            JSONObject jsonObject = new JSONObject();
            jsonObject.put("text", "DÃ©solÃ©, la rÃ©cupÃ©ration du planning d'exploit a Ã©chouÃ©. :ckc:");
            return jsonObject.toString();
        }

        Set<String> absents = new HashSet<>();
        for (Map.Entry<String, List<Pair<ZonedDateTime, ZonedDateTime>>> entry : exploit.holidays.entrySet()) {
            for (Pair<ZonedDateTime, ZonedDateTime> holiday : entry.getValue()) {
                if (holiday.getLeft().isBefore(ZonedDateTime.now()) && holiday.getRight().isAfter(ZonedDateTime.now())) {
                    // person currently in holidays
                    absents.add(formatName(entry.getKey()));
                    break;
                }
            }
        }

        JSONObject jsonObject = new JSONObject();
        jsonObject.put("response_type", "in_channel");
        jsonObject.put("text", absents.isEmpty() ? "Personne n'est absent actuellement !" :
                "**" + joinAll(absents) + (absents.size() == 1 ? "** est actuellement absent(e)." : "** sont actuellement absents."));
        return jsonObject.toString();
    }

    private String joinAll(Collection<String> strings) {
        long left = strings.stream().count();
        StringBuilder b = new StringBuilder("");
        for (String string : strings) {
            left--;
            b.append(string).append(left == 0 ? "" : (left == 1 ? "** et **" : "**, **"));
        }
        return b.toString();
    }

    private String formatName(String name) {
        return StringUtils.capitalize(name.substring(0, name.indexOf(" ")).toLowerCase(Locale.ROOT)) + name.substring(name.indexOf(" "));
    }

    private String commandRandomParrot() {
        try {
            Map<String, String> parrots = ParrotQuickImporterService.getParrots();
            List<String> parrotNames = new ArrayList<>(parrots.keySet());

            final int selected = (int) (Math.random() * parrotNames.size());

            HashMap<String, String> attachment = new HashMap<>();
            attachment.put("fallback", parrotNames.get(selected) + " : " + parrots.get(parrotNames.get(selected)));
            attachment.put("title", parrotNames.get(selected));
            attachment.put("image_url", parrots.get(parrotNames.get(selected)));

            JSONObject jsonObject = new JSONObject();
            jsonObject.put("response_type", "in_channel");
            jsonObject.put("attachments", Collections.singletonList(attachment));
            return jsonObject.toString();
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Problem with /randomparrot: " + e.toString());

            JSONObject jsonObject = new JSONObject();
            jsonObject.put("text", "DÃ©solÃ©, la rÃ©cupÃ©ration des parrots a Ã©chouÃ©. :ckc:");
            return jsonObject.toString();
        }
    }

    private String commandMonkeyUser() {
        List<String> links = new ArrayList<>();
        List<String> names = new ArrayList<>();

        final String sourceCode;

        try {
            sourceCode = IOUtils.toString(new URL("https://www.monkeyuser.com/").openStream(), UTF_8);
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Problem with /monkeyuser: " + e);

            JSONObject jsonObject = new JSONObject();
            jsonObject.put("text", "DÃ©solÃ©, la consultation de Monkey User a Ã©chouÃ©. :ckc:");
            return jsonObject.toString();
        }

        // comics are all in the source code of the page... in JS form. Extract them using epic regex
        final Pattern imageRegex = Pattern.compile("^\\s+images\\.push\\(\"([^\"]+)\"\\);");
        final Pattern titlesRegex = Pattern.compile("^\\s+titles\\.push\\(\"([^\"]+)\"\\);");
        for (String line : sourceCode.split("\n")) {
            Matcher m = imageRegex.matcher(line);
            if (m.matches()) {
                links.add("https://www.monkeyuser.com/assets/images/" + m.group(1));
            }

            m = titlesRegex.matcher(line);
            if (m.matches()) {
                names.add(m.group(1));
            }
        }

        if (links.size() == 0 || links.size() != names.size()) {
            // there are no links or we have more/less comic links than titles. it means there probably is a problem somewhere...
            logger.log(Level.SEVERE, "Problem while getting Monkey User comics: " + links.size() + " links and " + names.size() + " names found");

            JSONObject jsonObject = new JSONObject();
            jsonObject.put("text", "DÃ©solÃ©, la consultation de Monkey User a Ã©chouÃ©. :ckc:");
            return jsonObject.toString();
        }

        int selected;
        do {
            selected = (int) (Math.random() * links.size());
        } while (!links.get(selected).toLowerCase(Locale.ROOT).endsWith(".png"));

        HashMap<String, String> attachment = new HashMap<>();
        attachment.put("fallback", names.get(selected) + " : " + links.get(selected));
        attachment.put("title", names.get(selected));
        attachment.put("image_url", links.get(selected));

        JSONObject jsonObject = new JSONObject();
        jsonObject.put("response_type", "in_channel");
        jsonObject.put("attachments", Collections.singletonList(attachment));
        return jsonObject.toString();
    }

    private String commandXkcd() {
        final Document xkcd;

        try {
            xkcd = Jsoup.connect("https://c.xkcd.com/random/comic/").get();
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Problem while getting xkcd comic: " + e);

            JSONObject jsonObject = new JSONObject();
            jsonObject.put("text", "DÃ©solÃ©, la consultation de xkcd a Ã©chouÃ©. :ckc:");
            return jsonObject.toString();
        }

        String title = xkcd.select("#ctitle").text();
        String image = "https:" + xkcd.select("#comic img").attr("src");
        String description = xkcd.select("#comic img").attr("title");

        HashMap<String, String> attachment = new HashMap<>();
        attachment.put("fallback", title + " : " + image + "\n" + description);
        attachment.put("title", title);
        attachment.put("image_url", image);
        attachment.put("text", description);

        JSONObject jsonObject = new JSONObject();
        jsonObject.put("response_type", "in_channel");
        jsonObject.put("attachments", Collections.singletonList(attachment));
        return jsonObject.toString();
    }

    // this method compares the calendar used by /absents and one in a custom internal JSON format from another tool.
    // open-sourcing this has little interest, but...
    private String commandConsistencyCheck(String calendarString) {
        PlanningExploit exploit;
        try {
            exploit = cachedPlanningExploit == null ? getExploit() : cachedPlanningExploit;
        } catch (IOException e) {
            logger.log(Level.SEVERE, "Problem while getting exploit planning: " + e.toString());

            JSONObject jsonObject = new JSONObject();
            jsonObject.put("text", "DÃ©solÃ©, la rÃ©cupÃ©ration du planning d'exploit a Ã©chouÃ©. :ckc:");
            return jsonObject.toString();
        }

        List<String> issues = new ArrayList<>();

        JSONObject calendar = new JSONObject(calendarString);

        for (String userId : calendar.getJSONObject("users").keySet()) {
            String userName = calendar.getJSONObject("users").getJSONObject(userId).getString("name");

            // Nom PrÃ©nom => PRENOM NOM
            userName = (userName.substring(userName.lastIndexOf(" ") + 1) + " "
                    + userName.substring(0, userName.lastIndexOf(" "))).toUpperCase(Locale.ROOT);

            for (String month : calendar.getJSONObject("dates").keySet()) {
                final JSONObject monthUserObject = calendar.getJSONObject("dates").getJSONObject(month).getJSONObject("users").getJSONObject(userId);
                for (String day : monthUserObject.keySet()) {

                    final JSONObject dayUserObject = monthUserObject.getJSONObject(day);
                    LocalDate date = LocalDate.parse(day);

                    if (date.isBefore(LocalDate.now())) continue;

                    for (Object o : dayUserObject.getJSONArray("AM")) {
                        if ("absent".equals(o) && (!exploit.holidays.containsKey(userName) || exploit.holidays.get(userName).stream().noneMatch(holiday ->
                                holiday.getLeft().isBefore(date.atTime(8, 1, 0).atZone(ZoneId.of("Europe/Paris"))) &&
                                        holiday.getRight().isAfter(date.atTime(11, 59, 0).atZone(ZoneId.of("Europe/Paris")))))) {

                            // someone is declared absent in the tool but not in /absents (morning)
                            issues.add("**" + formatName(userName) + "** le " + DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT).withLocale(Locale.FRANCE)
                                    .format(date) + " matin");
                        }
                    }
                    for (Object o : dayUserObject.getJSONArray("PM")) {
                        if ("absent".equals(o) && (!exploit.holidays.containsKey(userName) || exploit.holidays.get(userName).stream().noneMatch(holiday ->
                                holiday.getLeft().isBefore(date.atTime(14, 1, 0).atZone(ZoneId.of("Europe/Paris"))) &&
                                        holiday.getRight().isAfter(date.atTime(17, 59, 0).atZone(ZoneId.of("Europe/Paris")))))) {

                            // someone is declared absent in the tool but not in /absents (afternoon)
                            issues.add("**" + formatName(userName) + "** le " + DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT).withLocale(Locale.FRANCE)
                                    .format(date) + " aprÃ¨s-midi");
                        }
                    }
                }
            }
        }

        JSONObject jsonObject = new JSONObject();
        jsonObject.put("response_type", "in_channel");
        jsonObject.put("text", issues.isEmpty() ? ":white_check_mark: Aucune dÃ©synchro Confluence n'a Ã©tÃ© dÃ©tectÃ©e pour les congÃ©s." :
                ":x: Il y a des dÃ©synchros Confluence pour les congÃ©s ! Ces congÃ©s ont Ã©tÃ© posÃ©s mais ne sont pas sur Confluence :\n- " + String.join("\n- ", issues));
        return jsonObject.toString();
    }

    private String commandInfoPipo() {
        try {
            JSONObject jsonObject = new JSONObject();
            jsonObject.put("response_type", "in_channel");
            jsonObject.put("text", "`" + IOUtils.toString(new URL("https://www.luc-damas.fr/pipotron/fail_geek/"), UTF_8) + "`");
            return jsonObject.toString();
        } catch (IOException e) {
            logger.log(Level.SEVERE, "Problem while getting info pipo: " + e);

            JSONObject jsonObject = new JSONObject();
            jsonObject.put("text", ":ckc:");
            return jsonObject.toString();
        }
    }

    /**
     * Ported from a website I cannot find anymore.
     */
    private String commandEddy() {
        final String[][] generator = {
                {"Chapitre abstrait 3 du conpendium :", "Câ€™est Ã  dire ici, câ€™est le contraire, au lieu de panacÃ©e,", "Au nom de toute la communautÃ© des savants,", "Lorsquâ€™on parle de tous ces points de vues,", "Câ€™est Ã  dire quand on parle de ces rollers,", "Quand on parle de relaxation,", "Nous nâ€™allons pas seulement danser ou jouer au football,", "D'une maniÃ¨re ou d'une autre,", "Quand on prend les triangles rectangles,", "Se consolidant dans le systÃ¨me de insiding et outsiding,", "Lorsque l'on parle des vÃ©gÃ©taliens, du vÃ©gÃ©talisme,", "Contre la morositÃ© du peuple,", "Tandis que la politique est encadrÃ©e par des scientifiques issus de Sciences Po et Administratives,", "On ne peut pas parler de politique administrative scientifique,", "Pour emphysiquer l'animalculisme,", "Comme la coumbacÃ©rie ou le script de Aze,", "Vous avez le systÃ¨me de check-up vers les anti-valeurs, vous avez le curuna, or", "La convergence nâ€™est pas la divergence,", "Lâ€™Ã©mergence ici câ€™est lâ€™Ã©mulsion, câ€™est pas lâ€™immersion donc", "Imbiber, porter", "Une semaine passÃ©e sans parler du peuple câ€™est errer sans abri, autrement dit", "Actuellement,", "ParallÃ¨lement,", "Mesdames et messieurs fidÃ¨les,"},
                {"la cosmogonisation", "l'activisme", "le systÃ¨me", "le rÃ©dynamisme", "l'ensemble des 5 sens", "la sociÃ©tÃ© civile", "la politique", "la compÃ©tence", "le colloque", "la contextualisation", "la congolexicomatisation", "la congolexicomatisation", "la congolexicomatisation", "la congolexicomatisation", "la prÃ©destination", "la force", "la systÃ©matique", "l'ittÃ©rativisme", "le savoir", "l'imbroglio", "la concertation politique", "la dÃ©lÃ©gation", "la pÃ©dagogie", "la rÃ©flexologie"},
                {"vers la compromettance pour des saint-bioules", "vers ce quâ€™on appelle la dynamique des sports", "de la technicitÃ© informatisÃ©e", "de la ThÃ©orie GÃ©nÃ©rale des Organisations", "autour de la GÃ©o Physique Spatiale", "purement technique", "des lois du marchÃ©", "de l'orthodoxisation", "inter-continentaliste", "Ã  l'Ã©gard de la complexitÃ©", "Ã©ventualiste sous cet angle lÃ ", "de toute la RÃ©publique DÃ©mocratique du Congo", "Ã  l'incognito", "autour de l'ergonomÃ©trie", "indispensable(s) en science et culture", "autour de phylogomÃ¨nes gÃ©nÃ©ralisÃ©s", "Ã  forciori,", "par rapport aux diplomaties"},
                {"tend Ã  ", "nous pousse Ã  ", "fait allusion Ã  ", "va ", "doit ", "consiste Ã  ", "nous incite Ã ", "vise Ã ", "semble", "est censÃ©(e)", "paraÃ®t", "peut", "s'applique Ã ", "consent Ã ", "continue Ã ", "invite Ã ", "oblige Ã ", "parvient Ã ", "pousse Ã ", "se rÃ©sume Ã ", "suffit Ã ", "se rÃ©soud Ã ", "sert Ã ", "tarde Ã "},
                {"incristaliser", "imposer", "intentionner ", "mettre un accent sur ", "tourner ", "informatiser ", "aider ", "dÃ©fendre ", "gÃ©rer ", "prÃ©valoir ", "vanter ", "rabibocher", "booster", "porter d'avis sur ce qu'on appelle", "cadrer", "se baser sur", "effaceter", "rÃ©glementer", "rÃ©gler", "faceter", "partager", "uniformiser", "dÃ©fendre", "soutenir", "propulser", "catapulter", "Ã©tablir"},
                {"les interchanges", "mes frÃ¨res propres", "les revenus", "cette climatologie", "une discipline", "la nuclÃ©aritÃ©", "l'upensmie", "les sens dynamitiels", "la renaissance africaine", "l'estime du savoir", "une kermesse", "une certaine compÃ©titivitÃ©", "cet environnement de 2 345 410 kmÂ²", "le kilomÃ©trage", "le conpemdium", "la quatripartie", "les encadrÃ©s", "le point adjacent", "la bijectivitÃ©", "le panafricanisme", "ce systÃ¨me phÃ©nomÃ©nal", "le systÃ¨me de Guipoti : 1/B+1/Bâ€™=1/D", "une position axisienne", "les grabuses lastiques", "le chicouangue", "le trabajo, le travail, la machinale, la robotisation", "les quatre carrÃ©s fous du fromage"},
                {"autour des dialogues intercommunautaires", "provenant d'une dynamique syncronique", "vers le monde entier", "propre(s) aux congolais", "vers Lovanium", "vers l'humanisme", "comparÃ©(e)(s) la rÃ©naque", "autour des gens qui connaissent beaucoup de choses", "possÃ©dant la francophonie", "dans ces prestances", "off-shore", "dans Kinshasa", "dans la sous-rÃ©gionalitÃ©", "dans le prÃ©mice", "belvÃ©dÃ¨re", "avec la formule 1+(2x5)", "axÃ©(e)(s) sur la rÃ©alitÃ© du terrain", "dans les camps militaires non-voyants", "avÃ©rÃ©(e)(s)", "comme pour le lancement de TroposphÃ¨re V"},
                {", tu sais Ã§a", ", câ€™est clair", ", je vous en prie", ", merci", ", mais oui", ", Bonne AnnÃ©e", ", bonnes fÃªtes"}
        };

        String s = "";
        for (String[] parts : generator) {
            String chosen = parts[(int) (Math.random() * parts.length)];

            s += " " + chosen;
        }

        s = s.substring(1).replace("  ", " ").replace(" ,", ",") + ".";

        JSONObject outputJSON = new JSONObject();

        outputJSON.put("response_type", "in_channel");
        outputJSON.put("text", s);
        return outputJSON.toString();
    }

    /**
     * Ported from https://www.pipotronic.com/
     */
    private String commandPipo(String param, String userName) {
        int count = 1;
        String phrases = "";

        String supMessage = "";

        if (param != null && !param.trim().isEmpty()) {
            try {
                count = Integer.parseInt(param);

                if (count > 5) {
                    // force-cap to 5
                    supMessage = "@" + userName + ": J'envoie 5 pipos au maximum. Ca suffit...";
                    count = 5;
                } else if (count <= 0) {
                    // messages in case the user invokes with 0 or less
                    switch ((int) (Math.random() * 5)) {
                        case 0:
                            phrases = "Tu veux que je te rÃ©ponde quoi au juste lÃ  ?";
                            break;
                        case 1:
                            phrases = "T'es sÃ©rieux ?";
                            break;
                        case 2:
                            phrases = "...";
                            break;
                        case 3:
                            phrases = "<rien du tout>";
                            break;
                        case 4:
                            phrases = "Hum... " + count + " pipos ? T'essaierais pas de me pipoter lÃ  ?";
                            break;
                    }

                    JSONObject outputJSON = new JSONObject();

                    outputJSON.put("response_type", "in_channel");
                    outputJSON.put("text", phrases);
                    return outputJSON.toString();
                }
            } catch (NumberFormatException nfe) {
                // invalid number, will default to 1
                supMessage = "@" + userName + ": La prochaine fois, passe-moi un nombre en paramÃ¨tre ;)";
            }
        }

        for (int l = 0; l < count; l++) {
            String[][] pipo = {
                    {"Face Ã ", "Relativement Ã ", "Pour optimiser", "Pour accentuer", "Afin de maÃ®triser", "Au moyen d#", "Depuis l'Ã©mergence d#", "Pour challenger", "Pour dÃ©fier",
                            "Pour rÃ©soudre", "En termes de redynamisation d#", "Concernant l'implÃ©mentation d#", "Ã€ travers", "En s'orientant vers", "En termes de process, concernant",
                            "En rebondissant sur", "Pour intÃ©grer", "Une fois internalisÃ©e", "Pour externaliser", "Dans la lignÃ©e d#", "En synergie avec",
                            "LÃ  oÃ¹ les benchmarks dÃ©signent", "Au cÅ“ur d#", "En auditant", "Une fois evaluÃ©e", "Partout oÃ¹ domine", "Pour rÃ©agir Ã ", "En jouant", "ParallÃ¨lement Ã ",
                            "MalgrÃ©", "En rÃ©ponse Ã ", "En rÃ©action Ã ", "RÃ©pliquant Ã ", "En phase de montÃ©e en charge d#", "En rÃ©ponse Ã ", "En phase de montÃ©e en charge d#", "GrÃ¢ce Ã ",
                            "Perpendiculairement Ã ", "IndÃ©pendamment d#", "CorrÃ©lativement Ã ", "Tangentiellement Ã ", "Concomitamment Ã ", "Par l'implÃ©mentation d#"
                    },
                    {"la problÃ©matique", "l'opportunitÃ©", "la mondialisation", "une globalisation", "la bulle", "la culture", "la synergie", "l'efficience", "la compÃ©titivitÃ©",
                            "une dynamique", "une flexibilitÃ©", "la revalorisation", "la crise", "la stagflation", "la convergence", "une rÃ©activitÃ©", "une forte croissance",
                            "la gouvernance", "la prestation", "l'offre", "l'expertise", "une forte supplÃ©ance", "une proposition de valeur", "une supply chain", "la dÃ©marche",
                            "une plate-forme", "une approche", "la mutation", "l'adaptabilitÃ©", "la pluralitÃ©", "une solution", "la multiplicitÃ©", "la transversalitÃ©",
                            "la mutualisation"
                    },
                    {"opÃ©rationnelle,", "quantitative,", "des expertises,", "porteuse,", "autoporteuse,", "collaborative,", "accÃ©lÃ©rationnelle,", "durable,", "conjoncturelle,",
                            "institutionnelle,", "managÃ©riale,", "multi-directionnelle,", "communicationnelle,", "organisationnelle,", "entrepreneuriale,", "motivationnelle,",
                            "soutenable,", "qualitative,", "stratÃ©gique,", "interne / externe,", "online / offline,", "situationnelle,", "rÃ©fÃ©rentielle,", "institutionnelle,",
                            "globalisante,", "solutionnelle,", "opÃ©rationnelle,", "compÃ©titionnelle,", "gagnant-gagnant,", "interventionnelle,", "sectorielle,", "transversale,",
                            "des prestations,", "ambitionnelle,", "des sous-traitances,", "corporate,", "asymÃ©trique,", "budget", "rÃ©fÃ©rentielle"
                    },
                    {"les cadres doivent ", "les personnels concernÃ©s doivent ", "les personnels concernÃ©s doivent ", "les N+1 doivent ", "le challenge consiste Ã ",
                            "le dÃ©fi est d#", "il faut", "on doit", "il faut", "on doit", "il faut", "on doit", "il faut", "on doit", "chacun doit", "les fournisseurs vont",
                            "les managers dÃ©cident d#", "les acteurs du secteur vont", "les responsables peuvent", "la conjecture peut", "il est impÃ©ratif d#",
                            "un meilleur relationnel permet d#", "une ambition s'impose :", "mieux vaut", "le marchÃ© exige d#", "le marchÃ© impose d#", "il s'agit d#",
                            "voici notre ambition :", "une rÃ©action s'impose :", "voici notre conviction :", "les bonnes pratiques consistent Ã ", "chaque entitÃ© peut",
                            "les dÃ©cideurs doivent", "il est requis d#", "les sociÃ©tÃ©s s'engagent Ã ", "les dÃ©cisionnaires veulent", "les experts doivent",
                            "la conjecture pousse les analystes Ã ", "les structures vont", "il faut un signal fort :", "la rÃ©ponse est simple :", "il faut crÃ©er des occasions :",
                            "la rÃ©ponse est simple :", "l'objectif est d#", "l'objectif est Ã©vident :", "l'ambition est claire :", "chaque entitÃ© doit", "une seule solution :",
                            "il y a nÃ©cessitÃ© d#", "il est porteur d#", "il faut rapidement", "il faut muscler son jeu : ", "la rÃ©ponse client permet d#",
                            "la connaissance des paramÃ¨tres permet d#", "les Ã©lÃ©ments moteurs vont"
                    },
                    {"optimiser", "faire interagir", "capitaliser sur", "prendre en considÃ©ration", "anticiper ", "intervenir dans", "imaginer", "solutionner", "piloter",
                            "dÃ©materialiser", "dÃ©localiser", "coacher", "investir sur", "valoriser", "flexibiliser", "externaliser", "auditer", "sous-traiter", "revaloriser", "habiliter",
                            "requalifier", "revitaliser", "solutionner", "dÃ©marcher", "budgetiser", "performer", "incentiver", "monitorer", "segmenter", "dÃ©senclaver", "dÃ©cloisonner",
                            "dÃ©ployer", "rÃ©inventer", "flexibiliser", "optimiser", "piloter", "rÃ©volutionner", "gagner", "rÃ©ussir", "connecter", "faire converger", "planifier",
                            "innover sur", "monÃ©tiser", "concrÃ©tiser", "impacter", "transformer", "prioriser", "chiffrer", "initiativer", "budgetiser", "rÃ©nover", "dominer"
                    },
                    {"solutions", "issues", "axes mobilisateurs", "problÃ©matiques", "cultures", "alternatives", "interactions", "issues", "expertises", "focus", "dÃ©marches",
                            "alternatives", "thÃ©matiques", "atouts", "ressources", "applications", "applicatifs", "architectures", "prestations", "process", "performances", "bÃ©nÃ©fices",
                            "facteurs", "paramÃ¨tres", "capitaux", "sourcing", "Ã©mergences", "kick-off", "recapitalisations", "produits", "frameworks", "focus", "challenges", "dÃ©cisionnels",
                            "ouvertures", "fonctionnels", "opportunitÃ©s", "potentiels", "territoires", "leaderships", "applicatifs", "prestations", "plans sociaux", "wordings",
                            "harcÃ¨lements", "monitorings", "montÃ©es en puissance", "montÃ©es en rÃ©gime", "facteurs", "harcÃ¨lements", "rÃ©fÃ©rents", "Ã©lÃ©ments", "nÃ©cessitÃ©s",
                            "partenariats", "retours d'expÃ©rience", "dispositifs", "potentiels", "intervenants", "directives", "directives", "perspectives", "contenus", "implications",
                            "kilo-instructions", "supports", "potentiels", "mind mappings", "thÃ©matiques", "workshops", "cÅ“urs de mission", "managements", "orientations", "cibles"
                    },
                    {"mÃ©tier", "prospect", "customer", "back-office", "client", "envisageables", "Ã  l'international", "secteur", "client", "vente", "projet", "partenaires", "durables",
                            "Ã  forte valeur ajoutÃ©e", "soutenables", "chiffrables", "Ã©valuables", "force de vente", "corporate", "fournisseurs", "bÃ©nÃ©fices", "convivialitÃ©",
                            "compÃ©titivitÃ©", "investissement", "achat", "performance", "Ã  forte valeur ajoutÃ©e", "dÃ¨s l'horizon 2020", "Ã  fort rendement", "qualitÃ©", "logistiques",
                            "dÃ©veloppement", "risque", "terrain", "mobilitÃ©", "praticables", "infrastructures", "organisation", "projet", "recevables", "investissement",
                            "conseil", "conseil", "sources", "imputables", "intermÃ©diaires", "leadership", "pragmatiques", "framework", "coordination", "d'excellence", "stratÃ©gie",
                            "de confiance", "crÃ©dibilitÃ©", "compÃ©titivitÃ©", "mÃ©thodologie", "mobilitÃ©", "efficacitÃ©", "efficacitÃ©"
                    }
            };

            String[] selectedPipos = new String[pipo.length];
            int i = 0;
            for (String[] pipoLine : pipo) {
                selectedPipos[i++] = pipoLine[(int) (Math.random() * pipoLine.length)];
            }

            for (i = 0; i < selectedPipos.length - 1; i++) {
                if (selectedPipos[i].endsWith("#")) {
                    if (selectedPipos[i + 1].startsWith("a")
                            || selectedPipos[i + 1].startsWith("e")
                            || selectedPipos[i + 1].startsWith("i")
                            || selectedPipos[i + 1].startsWith("o")
                            || selectedPipos[i + 1].startsWith("u")
                            || selectedPipos[i + 1].startsWith("y")) {
                        selectedPipos[i] = selectedPipos[i].substring(0, selectedPipos[i].length() - 1) + "'";
                    } else {
                        selectedPipos[i] = selectedPipos[i].substring(0, selectedPipos[i].length() - 1) + "e ";
                    }
                } else {
                    selectedPipos[i] += " ";
                }
            }

            String phrase = (selectedPipos[0] + " "
                    + selectedPipos[1] + " "
                    + selectedPipos[2] + " "
                    + selectedPipos[3] + " "
                    + selectedPipos[4] + " les "
                    + selectedPipos[5] + " "
                    + selectedPipos[6] + ".");

            while (phrase.contains("  "))
                phrase = phrase.replace("  ", " ");
            phrase = phrase.replace("' ", "'");
            phrase = phrase.replace(" .", ".");

            phrase = "_" + phrase + "_";

            if (phrases.isEmpty()) phrases = phrase;
            else phrases += "\n" + phrase;
        }

        if (!supMessage.isEmpty()) {
            phrases += "\n" + supMessage;
        }

        JSONObject outputJSON = new JSONObject();
        outputJSON.put("response_type", "in_channel");
        outputJSON.put("text", phrases);
        return outputJSON.toString();
    }

    private String commandWeekend(String userName) {
        String endingPhrase = "*C'est le week-end \\o/*";
        String notFinishedPhrase = "@" + userName + ", le week-end est dans ";

        // weekend is at 6pm on Friday. Go back if today is Saturday or Sunday.
        ZonedDateTime zdt = ZonedDateTime.now().withZoneSameInstant(ZoneId.of("Europe/Paris"));
        while (zdt.getDayOfWeek() != DayOfWeek.FRIDAY) {
            if (Arrays.asList(DayOfWeek.SATURDAY, DayOfWeek.SUNDAY).contains(zdt.getDayOfWeek())) {
                zdt = zdt.minusDays(1);
            } else {
                zdt = zdt.plusDays(1);
            }
        }
        zdt = zdt.withHour(18).withMinute(0).withSecond(0).withNano(0);

        long time = zdt.toInstant().toEpochMilli();
        long now = System.currentTimeMillis();

        long seconds = ((time - now) / (1000));
        long minutes = seconds / 60;
        seconds %= 60;

        long hours = minutes / 60;
        minutes %= 60;

        long days = hours / 24;
        hours %= 24;

        JSONObject outputJSON = new JSONObject();
        String phrase;
        if (time - now < 0) {
            phrase = endingPhrase;
        } else {
            phrase = notFinishedPhrase
                    + (days == 0 ? "" : days + " jour(s), ") + hours + " heure(s), " + minutes + " minute(s) et " + seconds + " seconde(s) !";
        }

        outputJSON.put("response_type", "in_channel");
        outputJSON.put("text", phrase);
        return outputJSON.toString();
    }

    /**
     * This is ported straight from JS from https://lunatopia.fr/blog/films-de-noel
     */
    private static class ChristmasFilmGenerator {
        private static final String[] titre = new String[]{"12 cadeaux pour NoÃ«l", "Une mariÃ©e pour NoÃ«l", "Le dÃ©tour de NoÃ«l",
                "Un duo pour NoÃ«l", "La mÃ©lodie de NoÃ«l", "Un NoÃ«l de conte de fÃ©es", "Un NoÃ«l de rÃªve", "Un rÃªve pour NoÃ«l",
                "Des cookies pour NoÃ«l", "La mariÃ©e de dÃ©cembre", "Un mariage pour NoÃ«l", "Un cadeau de rÃªve", "Un NoÃ«l parfait",
                "Un NoÃ«l royal", "Un prince pour NoÃ«l", "Un vÅ“ux pour NoÃ«l", "Le meilleur NoÃ«l", "NoÃ«l en famille", "L'aventure de NoÃ«l",
                "La buche de NoÃ«l", "Un noÃ«l enchantÃ©", "Le meilleur des cadeaux", "Un cadeau de rÃªve", "L'amour en cadeau", "Un amour de NoÃ«l",
                "Le NoÃ«l de l'amour", "L'amour en hÃ©ritage", "L'hÃ©ritage de NoÃ«l", "Une surprise pour NoÃ«l", "Une lettre au pÃ¨re NoÃ«l", "La liste de NoÃ«l",
                "Un NoÃ«l Ã  emporter", "NoÃ«l en fÃªte", "NoÃ«l sous les Ã©toiles", "Une couronne pour NoÃ«l", "Un NoÃ«l courronnÃ©", "Je t'aime comme NoÃ«l",
                "Ã‰pouse moi pour NoÃ«l", "Miss NoÃ«l", "Mister NoÃ«l", "Mon amour de NoÃ«l", "Mon rÃªve de NoÃ«l", "Un rÃªve pour NoÃ«l", "Des vacances de rÃªve",
                "Il Ã©tait une fois Ã  NoÃ«l", "Le calendrier de l'avent", "Orgueil, prÃ©jugÃ©s et cadeaux sous le sapin", "De l'amour sous le sapin",
                "Un baiser sous le gui", "L'amour sous le gui", "RÃ©union de NoÃ«l", "Des retrouvailles Ã  NoÃ«l", "En route pour NoÃ«l", "MariÃ©e d'hiver",
                "La promesse de NoÃ«l", "Une promesse sous le gui", "Le secret de NoÃ«l", "Un secret pour NoÃ«l", "Un secret sous le sapin",
                "Le plus beau jour de l'annÃ©e", "Le plus beau NoÃ«l de ma vie", "Le plus beau cadeau de ma vie", "Les neufs vies de NoÃ«l", "Le plus beau des NoÃ«l",
                "Le plus doux des NoÃ«l", "La carte de NoÃ«l"};

        private static final String[] nomMeuf = new String[]{"Lacey Charm", "Alicia Witt", "Ambert McIver", "Ava Mitchell", "April McDonagall", "Kristin Elliott",
                "Candace Cameron Burke", "Emily McLayne", "Jessie Jones", "Candice Everdeen", "Kaylynn Riley McAlistair", "Alexandra McKintosh", "Abbey Patterson",
                "Cate Sweetin", "Jodie Walker", "Belinda Shaw", "Merritt Patterson", "Nancy Davis", "Candy McLair", "Donna Mills", "Christie Reynolds", "Pennie Miller"};

        private static final String[] nomMec = new String[]{"Nick Cane", "Richard Wright", "Gabriel Hogan", "Edgar Jones", "Rory Gallagher", "Sam Page", "Gabe Walker",
                "Eon Bailey", "Brennan Hebert", "Dylon O'Neil", "Henri Walsh", "Andrew Mann", "Dustin McGary", "Matthew McDonagall", "Brian McAlistair"};

        private static final String[] etat = new String[]{"Ohio", "Nebraska", "Wisconsin", "Wyoming", "Oregon", "Montana", "Minnesota", "Maine", "Vermont",
                "Connecticut", "Kentucky", "Texas", "Missouri", "Illinois", "Indiana", "Arizona", "Arkansas", "Oklahoma", "Iowa", "Kansas", "Colorado",
                "Idaho", "Nevada", "Utah"};

        private static final String[] petiteVille = new String[]{"Ridgetown", "Riverside", "Winslow", "Eureka", "Carmel", "New Castle", "Crystal River", "Franklin",
                "Fairfield", "Greenville", "Kingston", "Springfield", "Arlington", "Georgetown", "Madison", "Salen", "Old Lebanon", "Port Clinton", "Ashland",
                "Ashville", "Fort Jackson", "Milton", "Newport", "Clayton", "Dayton", "Lexington", "Milford", "Winchester", "Port Hudson", "Davenportside", "Burbank",
                "Lakewood", "Marion Falls", "Sioux Falls", "Edison", "Arlingwood", "Ann Arbor", "Mary Valley", "Thousand Oaks", "Treehills", "Kentford",
                "Port New Haven", "Crystal Falls"};

        private static final String[] grandeVille = new String[]{"New-York", "Los Angeles", "Chicago", "San Francisco", "Seattle", "Washington", "Las Vegas", "Manhattan"};

        private static final String[] metierMeuf = new String[]{"styliste", "dÃ©coratrice d'intÃ©rieur", "photographe de mode", "photographe de sports extrÃªmes", "avocate",
                "agent immobilier", "illustratrice de livres pour enfants", "pianiste de renommÃ©e mondiale", "cheffe d'entreprise", "publiciste", "graphiste",
                "directrice de communication", "guide touristique", "journaliste dans la mode", "architecte", "architecte d'intÃ©rieur", "organisatrice de mariage"};

        private static final String[] metierMec = new String[]{"directeur d'Ã©cole", "Ã©leveur", "fermier", "Ã©beniste", "potier", "cÃ©ramiste", "libraire", "vÃ©tÃ©rinaire",
                "fleuriste", "sculpteur sur glace"};

        private static final String[] histoire = new String[]{"laMeuf, avocate dans l'immobilier, fait la rencontre de leMec, un petit libraire qui essaye d'empÃªcher la construction du centre commercial dont elle s'occupe. Va-t-elle abandonner ses projets par amour ?",
                "laMeuf, metierCool qui travaille beaucoup trop, est obligÃ©e de retourner dans son etatPaume natal pour s'occuper de l'hÃ©ritage de sa grand-mÃ¨re et fait la rencontre de leMec, jeune vÃ©tÃ©rinaire de la ville. Entre sa vie Ã  bigCity avec un salaire Ã  5 chiffre et les plaisirs simples de la campagne, le choix va Ãªtre difficile&nbsp;!",
                "laMeuf, metierCool Ã  bigCity, rentre Ã  contre-cÅ“ur passer les fÃªtes en famille. Les choses empirent quand elle se retrouve obligÃ©e Ã  faire Ã©quipe avec son ex, leMec, pour la chasse au trÃ©sor de NoÃ«l de villePaume, etatPaume, sa ville natale.",
                "Dans 4 jours, laMeuf doit Ã©pouser un ambitieux milliardaire, mais sa rencontre avec leMec, le traiteur de la cÃ©rÃ©monie, va tout remettre en question.",
                "TrÃ¨s investie dans sa carriÃ¨re de metierCool, laMeuf retourne Ã  villePaume, sa ville natale, pour veiller sur sa grand-mÃ¨re. Celle-ci lui prÃ©sente leMec, jeune metierVrai, qui aurait bien besoin d'aide pour organiser le bal de NoÃ«l.",
                "Ã€ quelques semaines de NoÃ«l, laMeuf est embauchÃ©e pour dÃ©corer les locaux de CandyCane Corp. Elle devra composer avec leMec, le PDG, qui a succÃ©dÃ© Ã  son pÃ¨re Ã  la tÃªte de l'entreprise, mais dÃ©teste NoÃ«l.",
                "Quand une jeune mariÃ©e se voit accorder un vÅ“ux par l'ange de NoÃ«l, elle souhaite devenir cÃ©libataire Ã  nouveau. Mais sa vie de femme libre n'est pas aussi Ã©panouissante qu'elle l'aurait cru, et elle se met en tÃªte de reconquÃ©rir son mari.",
                "laMeuf et Mandie McKinnie sont rivales depuis que cette derniÃ¨re a trichÃ© au concours annuel de cookies en 4e. Elles travaillent dÃ©sormais dans la mÃªme Ã©cole, et sont en compÃ©tition constante. L'arrivÃ©e en ville de leMec, un jeune metierVrai amoureux de la patisserie qui propose de faire renaÃ®tre le concours annuel de cookies va mettre le feu aux poudres&nbsp;!",
                "laMeuf, jeune divorcÃ©e et metierCool, donnerait tout pour sa fille Emma. ForcÃ©e de fermer sa boutique de bigCity, le retour dans son etatPaume natal est rude. Heureusement, le professeur de musique d'Emma, leMec, les aide Ã  s'ajuster Ã  cette nouvelle vie.",
                "Deux New-Yorkais se retrouvent bloquÃ©s par une tempÃªte de Neige Ã  villePaume, etatPaume. laMeuf, dÃ©sespÃ©rÃ©ment romantique, doit trouver un moyen de se rendre chez ses beaux parents Ã  temps pour sa soirÃ©e de fianÃ§ailles. Heureusement, leMec, cÃ©libataire endurci, va l'aider&hellip;",
                "Alors qu'elle vient d'abandonner son 3Ã¨me fiancÃ© Ã  l'autel, laMeuf jure de renoncer Ã  toute relation jusqu'Ã  ce qu'elle trouve Â«&nbsp;le bon&nbsp;Â». Mais sa rencontre avec leMec, metierVrai, cÃ©libataire endurci plein de charme, va mettre sa promesse Ã  rude Ã©preuve.",
                "Lors d'une soirÃ©e un peu trop arrosÃ©e, leMec a fait un pari&nbsp;: il doit convaincre une femme de l'Ã©pouser avant NoÃ«l, soit dans 4 semaines&nbsp;! Il jette son dÃ©volu sur laMeuf, la talentueuse metierCool qu'il vient d'embaucher.",
                "laMeuf vient de perdre son emploi de metierCool. Elle rencontre par hasard leMec, patron surbookÃ© qui la charge d'acheter ses cadeaux de NoÃ«l. Elle va lui transmettre l'esprit de NoÃ«l et bien plus encore&hellip;",
                "Quand on l'envoie superviser les travaux de rÃ©novation d'un hÃ´tel perdu Ã  villePaume, etatPaume, laMeuf s'attends Ã  passer le pire NoÃ«l de sa vie. C'est compter sans la prÃ©sence de leMec, conducteur de chantier bourru qui va lui faire dÃ©couvrir le charme de la vie Ã  la campagne&hellip;",
                "laMeuf, journaliste Ã  bigCity, bÃ¢cle un article capital. En guise de punition, on l'envoie Ã  villePaume, etatPaume, faire un reportage sur leMec, metierVrai. Il est veuf, revÃªche et taciturne. Ils se dÃ©testent. Puis la magie de NoÃ«l entre en jeu&hellip;",
                "FraÃ®chement plaquÃ©e par son mari, laMeuf retourne vivre chez ses parents dans son etatPaume natal. Elle fait la rencontre de leMec, metierVrai grincheux et moqueur. Ils se dÃ©testent au premier regard&hellip;",
                "Lorsque laMeuf, metierCool, rencontre leMec, elle est loin de se douter qu'il est le prince hÃ©ritier de CÃ©novie en visite incognito Ã  villePaume, etatPaume.",
                "laMeuf, jeune hÃ©ritiÃ¨re frivole, est envoyÃ©e par ses parents Ã  villePaume, etatPaume pour apprendre la valeur du travail et le sens des autres. Heureusement, leMec, metierVrai, saura l'aider&hellip;",
                "La ville de villePaume, etatPaume est frappÃ©e par une tempÃªte de neige. laMeuf, metierCool, est bloquÃ©e plusieurs jours et doit apprendre la patience. Heureusement, leMec, jeune metierVrai bourru, est lÃ  pour l'aider.",
                "Tout juste dÃ©barquÃ©e Ã  villePaume, etatPaume aprÃ¨s une rupture difficile, laMeuf, jeune citadine metierCool, fait la connaissance de leMec, metierVrai qui lui fait dÃ©couvrir l'amour.",
                "Quand leMec, metierVrai romantique, et laMeuf, metierCool de bigCity qui ne croit plus en l'amour, se rencontrent, ils n'ont rien en commun. Et pourtant, ils vont devoir faire Ã©quipe pour organiser la parade de NoÃ«l de villePaume, etatPaume.",
                "laMeuf, jeune metierCool Ã  bigCity, semble tout avoir&nbsp;: une carriÃ¨re en constante Ã©volution et un riche fiancÃ© prÃ©nommÃ© Alistair. Ã€ la mort de sa grand-mÃ¨re, elle hÃ©rite de sa ferme de NoÃ«l Ã  villePaume, etatPaume. Venue faire le tour de la propriÃ©tÃ© pour la vendre au riche promoteur Milton McDollar, elle rencontre le charmant leMec, metierVrai trÃ¨s attachÃ© Ã  la ferme&hellip;",
                "Quand Elena et laMeuf, sÅ“urs jumelles se retrouvent invitÃ©es Ã  des soirÃ©es de NoÃ«l qui ne les intÃ©ressent pas, elles dÃ©cident d'Ã©changer leur place pendant les fÃªtes. Les leÃ§ons qu'elles vont apprendre vont changer leurs vies Ã  jamais.",
                "laMeuf vit les pires vacances de sa vie&nbsp;: son fiancÃ© vient de la plaquer et une grÃ¨ve aÃ©rienne l'oblige Ã  prolonger ses vacances Ã  villePaume, etatPaume. Pour ne rien arranger, l'hÃ´tel de luxe qu'elle avait rÃ©servÃ© est plein, et elle doit partager une auberge rustique avec leMec, metierVrai bourru."
        };

        private static String draw(String[] array) {
            return array[(int) (Math.random() * array.length)];
        }

        static String generateStory() {
            String storyFull = draw(histoire)
                    .replace("laMeuf", draw(nomMeuf))
                    .replace("leMec", draw(nomMec))
                    .replace("etatPaume", draw(etat))
                    .replace("villePaume", draw(petiteVille))
                    .replace("bigCity", draw(grandeVille))
                    .replace("metierCool", draw(metierMeuf))
                    .replace("metierVrai", draw(metierMec));

            storyFull = StringEscapeUtils.unescapeHtml4(storyFull);
            String titleFull = draw(titre);
            int posterIndex = (int) (Math.random() * 83);

            HashMap<String, String> attachment = new HashMap<>();
            attachment.put("fallback", "**" + titleFull + "**\n" + storyFull);
            attachment.put("title", titleFull);
            attachment.put("text", storyFull);
            attachment.put("image_url", "http://lunatopia.fr/media/pages/blog/films-de-noel/" + posterIndex + ".jpg");

            JSONObject jsonObject = new JSONObject();
            jsonObject.put("response_type", "in_channel");
            jsonObject.put("attachments", Collections.singletonList(attachment));

            return jsonObject.toString();
        }
    }
}
